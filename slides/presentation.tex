\documentclass{beamer}

\input{theme}

\input{config}

\input{commands}

\begin{document}

\AtBeginSection[]{
  \begin{frame}
    \frametitle{Overview}
    \tableofcontents[currentsection, hideothersubsections]
  \end{frame} 
}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{Overview}
  \tableofcontents[hideothersubsections]
\end{frame}

\section{Pure functions}

\codeslide{Impure function}{pure_functions/side_effects_bad.java}

\codeslide{Removing side effects}{pure_functions/side_effects_good.java}

\codeslide{Removing modification of input}{pure_functions/eventCollector.java}

\codeslide{Simplifying}{pure_functions/eventCollector_better.java}

\codeslide{Removing non-determinism}{pure_functions/random.java}

\codeslide{Simplifying}{pure_functions/random_better.java}

\codeslide{Testing}{pure_functions/Testing.java}

\codeslide{Documentation by signature}{pure_functions/Signatures.java}

\codeslide{Usage in Stream API}{pure_functions/Usage.java}

\section{Optionals}

\codeslide{Null usage}{optional/NonOptionalIncorrect.java}

\codeslide{Null usage}{optional/NonOptional.java}

\codeslide{With Optional}{optional/WithOptionalBad.java}

\codeslide{With Optional}{optional/WithOptional.java}

\codeslide{Without Null}{optional/WithoutNull.java}

\codeslide{Interacting with legacy code}{optional/LegacyAPIs.java}

\section{Either}

\codeslide{Checked Exceptions vs. Lambdas}{optional/CheckedExceptionsProblem.java}

\codeslide{Either to the rescue}{either/CheckedExceptionsProblemSolved.java}

\section{Streams}

\codeslide{Working on a list the traditional way}{stream/Example_bad.java}

\codeslide{Using the Stream API}{stream/Example.java}

\codeslide{Using the Stream API badly}{stream/Example_bad_foreach.java}

\slide{Finitely representable}{finitely_representable}

\slide{Finitely representable}{finitely_representable_examples}

\codeslide{The problem with finite lists}{stream/infinite/Primenumbers.java}

\codeslide{A solution without infinite streams}{stream/infinite/PrimenumbersWithoutInfinity.java}

\codeslide{How infinite lists can help us}{stream/infinite/PrimenumbersWithStreams.java}

\section{The evil 'M'-word}

\slide{Functors}{map_examples}

\slide{Functor properties}{functor_property}

\slide{Definition}{monad_definition}

\slide{Of Examples}{of_examples}

\slide{Flatten Examples}{flatten_examples}

\slide{Monad properties}{monad_properties}

\slide{Monad Examples}{monad_examples}

\section{Mutability}

\codeslide{Mutable bank account}{object_orientation/Mutable.java}

\codeslide{The problem with mutability}{object_orientation/MutableProblem.java}

\codeslide{Immutable bank account}{object_orientation/Immutable.java}

\codeslide{Immutability to the rescue}{object_orientation/ImmutableToTheRescue.java}

\appendix
\backupbegin

\section{Easy class creation vs. easy method creation}

\codeslide{Interfaces}{easy_class_vs_method/Hierarchie.java}

\codeslide{Method Extension Problem}{easy_class_vs_method/MethodExtensionProblem.java}

\codeslide{Sleep as a function}{easy_class_vs_method/SleepAsFunction.java}

\codeslide{Sleep as a function}{easy_class_vs_method/SleepAsFunction.kt}

\backupend

\end{document} 
